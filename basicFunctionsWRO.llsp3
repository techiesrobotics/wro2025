from hub import light_matrix, motion_sensor, port
from motor import relative_position
import runloop, motor_pair, color_sensor, math, time, motor, color

WHEEL_SIZE = 17.5
DEGREES_PER_CM = 360/WHEEL_SIZE
TURN_TYPE_SPIN = 100 
TURN_TYPE_PIVOT = 50

def lineFollowWithDistance(distanceByCM, speed):
    while motor.relative_position(port.E) < DEGREES_PER_CM*distanceByCM:
        motor_pair.move(motor_pair.PAIR_1,(math.floor(-3/5)*color_sensor.reflection(port.A)+30),velocity=speed)
    motor_pair.stop(motor_pair.PAIR_1)

def gyroStraightWithDistance(distanceByCM, speed):
    motion_sensor.reset_yaw(0)
    distance_degrees = int(distanceByCM * DEGREES_PER_CM)

    motor.reset_relative_position(port.E, 0)
    while abs(motor.relative_position(port.E)) < distance_degrees:
        error = motion_sensor.tilt_angles()[0] * -0.1
        correction = int(error * -2)
        #print(motor.relative_position(port.E))
        motor_pair.move(motor_pair.PAIR_1, correction, velocity=speed)
    motor_pair.stop(motor_pair.PAIR_1)

    motion_sensor.reset_yaw(0)

def gyroStopAtBlackLine(speed):
    motion_sensor.reset_yaw(0)
    motor.reset_relative_position(port.E, 0)

    while color_sensor.color(port.A) != color.BLACK:
        error = motion_sensor.tilt_angles()[0] * -0.1
        correction = int(error * -2)
        motor_pair.move(motor_pair.PAIR_1, correction, velocity=speed)
    motor_pair.stop(motor_pair.PAIR_1)

def gyroBackwardsWithDistance(distanceByCM, speed):
    motion_sensor.reset_yaw(0)
    distance_degrees = int(distanceByCM * DEGREES_PER_CM)

    motor.reset_relative_position(port.E, 0)
    while abs(motor.relative_position(port.E)) < distance_degrees:
        error = motion_sensor.tilt_angles()[0] * -0.1
        correction = int(error * -2)
        #print(motor.relative_position(port.E))
        motor_pair.move(motor_pair.PAIR_1, correction, velocity=(-1*speed))
    motor_pair.stop(motor_pair.PAIR_1)

    motion_sensor.reset_yaw(0)

def gyroBackwardsStopAtBlackLine(speed):
    motion_sensor.reset_yaw(0)
    motor.reset_relative_position(port.E, 0)

    while color_sensor.color(port.A) != color.BLACK:
        error = motion_sensor.tilt_angles()[0] * -0.1
        correction = int(error * -2)
        motor_pair.move(motor_pair.PAIR_1, correction, velocity=(-1*speed))
    motor_pair.stop(motor_pair.PAIR_1)

def gyroTurnRight(angle):
    while abs(motion_sensor.tilt_angles()[0]) < angle:
        motor_pair.move(motor_pair.PAIR_1, 100)
    motor_pair.stop(motor_pair.PAIR_1)

def gyroTurnLeft(angle):
    while(abs(motion_sensor.tilt_angles()[0]) < angle):
        motor_pair.move(motor_pair.PAIR_1, -100);
    motor_pair.stop(motor_pair.PAIR_1)

def pivotTurnRight(angle):
    while abs(motion_sensor.tilt_angles()[0]) < angle:
        motor_pair.move(motor_pair.PAIR_1, 50)
    motor_pair.stop(motor_pair.PAIR_1)

def pivotTurnLeft(angle):
    while abs(motion_sensor.tilt_angles()[0]) < angle:
        motor_pair.move(motor_pair.PAIR_1, -50)
    motor_pair.stop(motor_pair.PAIR_1)

def gyroTurnRight(turn_Type, degrees, speed):
    global TURN_TYPE_SPIN, TURN_TYPE_PIVOT
    motion_sensor.reset_yaw(0)
    while True:
        if abs(motion_sensor.tilt_angles()[0]) < degrees * 10:
            motor_pair.move(motor_pair.PAIR_1, turn_Type, velocity=speed) 
        else:
            motor_pair.stop(motor_pair.PAIR_1)
            break

 def gyroTurnLeft(turn_Type, degrees, speed): # turns right at specified degrees (0 to 90), using Gyro or motion sensor
    global TURN_TYPE_SPIN, TURN_TYPE_PIVOT
    motion_sensor.reset_yaw(0)
    
    while abs(motion_sensor.tilt_angles()[0])< degrees *10: # robot gyro sensor reads value and compared it to preset degrees
        motor_pair.move(motor_pair.PAIR_1, -1 * turn_Type, velocity=speed) # robot turns to left
    motor_pair.stop(motor_pair.PAIR_1)

async def main():
    motor_pair.unpair(motor_pair.PAIR_1)
    motor_pair.pair(motor_pair.PAIR_1,port.E,port.F)

runloop.run(main())
